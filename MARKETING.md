# Marketing

## Fantasy

A program was executed. It gave birth to a Temporal Logic Space, a world of connections between things that happened and things that caused them. Your job is to explore the Temporal Logic Space and find out what went wrong.

You are a time-travelling wizard in an orange robe. You can walk around and cast spells. You can make things reveal their true nature and why it came to be. You can draw symbols and teleport between them. You can also teleport between similar locations, and cause and effect.

All that will help you accomplish your heroic task of figuring out why the world is not as it should be. For really nasty problems, you can write your own spells to conjure up a more intuitive way of looking at things. By that, I mean you can write scripts to gather data and display it in custom ways. Except it feels like a game.

You can combine spells and make them do more damage by writing macros. You can move around, interact with the environment, and explore a vast open world on your quest to smite the evil bug queen.

Function calls and loop cycles are natural caves with memorable environments and recognizable landmarks. Self-contained blocks of code are rooms and levels. You can save your progress and revisit old areas. Every step is small and simple, so there is always something you can do to make the final task easier. You can plan out your moves, craft special abilities, and create a strategy to finish that annoying boss level. There is no leveling system, only raw skill and well-tuned mechanics.

Uncovering secrets and exploring the Temporal Logic Space truly feels like an adventure.

Let's back up a bit.

What I've just described is a debugger, not a game. Except it feels like a game. It uses the principles of game design to make debugging fun and engaging, just like a fantasy role-playing action game with puzzles. It adds some much needed features like backtracking and visualization that are missing from most debuggers today. There are also some tiny things that make the debug experience as smooth as it should be.

The main thing that sets this debugger apart from others is that anything the computer can do, you don't have to. You don't have to remember values, calculate things in your head, or speculate where the values came from and how they were used. You don't have to assume that some code ran or that it didn't. You don't even have to visualize things mentally, you can just write scripts to gather and display data, and keep them for later analysis.

Notoriously, computers can't tell the difference between right and wrong, that is, correctly executed code and a bug. Because the computer does the boring work, you can focus all your mental resources on the only thing the computer can't do, which is figuring out what went wrong.