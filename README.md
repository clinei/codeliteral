# CodeLiteral

It's a game that turns the execution of your program into a procedurally generated world where the bugs are the quest items. The vast open world is a syntax tree of the executed program. You can explore that tree using intuitive keyboard controls, moving between lines, reads and writes, or different uses of the same code. The syntax tree stores the values of variables as delicious informative apples. So you debug by walking around an informative apple orchard.

#### Learn

Move around and understand the program flow. Look at the data all at once and understand what's really going on. Never get lost.

#### Debug

Find out why the value was wrong by pressing just one button. Create custom tools to gather data and visualize the problem.

#### Document

Mark points of interest and the intended program flow. Make your documentation interactive. Reuse debug visualizations and explain the most arcane concepts. Save it all to a file.

#### Automate

Use the fully scriptable user interface to make custom tools and automate the most frequent tasks, like testing.


## What makes this so good?

#### Simplicity

Everything is easy. Most questions are answered by looking around or pressing one button.

#### Power

Everything is scriptable. You can gather any data you want, and show it any way you want. You can write macros and automate the interface.

#### Sharing

Debugging, documenting, and testing all use the same data gathering and visualization workflows. That means you can reuse most of the code you write. You can also use the code from your actual program. And you can save it to a file and send it to your colleagues or save it for audits or private nostalgia. Or maybe wait 20 years and sell it to a museum.


## What can I do that I couldn't before?

#### Save and resume debug sessions

Different people can do different stages of debugging: one records the problem, one finds the causes, one makes visualizations, one fixes the problem. Or it can all be done by one person, just at different times. The point is that you don't lose all your progress when you don't solve the problem in one go, or when you give it to someone else.

#### Rapidly debug complex problems

The following situation will never happen: you step over a call, ruin the program state, and spend the next 10 minutes setting up the state to reproduce the bug again. You have as much time as you need to understand the problem. All the data is plainly visible for you to glance over and solve the problem in 5 seconds. You can jump between reads and writes and anything else you've marked as interesting. You can find the right way to visualize the problem. Moving around keeps you awake and energetic. It's a game, it keeps up your motivation so you don't have to.

#### Inline testing

Instead of testing return values, you check the actual value of an expression as the code ran. Testability is no longer a problem. The whole execution is one syntax tree, easy to process.

#### Data analysis of execution

You don't have to add any code to get specific statistics about your code. All the familiar debug tools can be used to answer the hardest questions you may have about your program.