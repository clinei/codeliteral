# CodeLiteral

Debugger that turns the executed program into a syntax tree. You can explore that tree using intuitive keyboard controls, moving between lines and more complex relationships between code elements, like reads and writes, or repetitions of the same code.

### Learn

Move around and understand the program flow. Look at all the data at once and understand what's really going on. Never get lost.

### Debug

Find out why the value was wrong by pressing just one button. Create custom tools to gather data and visualize the problem.

### Document

Mark points of interest and the intended program flow. Make your documentation interactive. Reuse debug visualizations and explain the most arcane concepts. Save it all to a file.

### Automate

Use the fully scriptable user interface to make custom tools and automate the most frequent tasks, like testing.


## What makes this so good?

### Simplicity

Everything is easy. Most questions are answered by looking around or pressing one button.

### Power

Everything is scriptable. You can gather any data you want, and show it any way you want. You can write macros and automate the interface.

### Sharing

Debugging, documenting, and testing all use the same data gathering and visualization workflows. That means you can reuse most of the code you write. You can also use the code from your actual program. And you can save it to a file and send it to your colleagues or save it for audits or private nostalgia. Or maybe wait 20 years and sell it to a museum.


## What does this make possible?

### Saving and resuming debug sessions

Different people can do different stages of debugging: one records the problem, one finds the causes, one makes visualizations, one fixes the problem.

### Rapid debugging of complex problems

You can never step over a function and lose your progress. You can jump between reads and writes and points of interest you have marked. You can find the right way to visualize the problem.