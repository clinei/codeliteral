Important:

blah

structs need alignment padding

time for scrolling and moving with WASD

push_index was only for run_lvalue for strings, do not implement

printf needs varargs

we should have a comment on the general design

Bugs:

else if can put a transformed block between an else if chain, not good visually

reallocation of type_infos and code_node_array means we have to fix pointers in the tree
we have to calculate the diff of the last block and then add that to every pointer

scrolling not implemented

we call the left hand side "ident",
that is wrong, it's an lvalue
we should rename it

unary minus and not operators not implemented

when we show values or changes, save the previous cursor, 
and when we go back and haven't moved, set the cursor back to the previous one
`m = a.[b].c` (F) `m = [42]` (F) `m = a.[b].c`
`m = a.[b].c` (F) `m = [42]` (A) `[m] = 42` (F) `[m] = a.b.c`

pressing V should only show parens when operator precedence changes

dynamic arrays as structs,
static arrays as pointers
array concatenation

casts
test ints

Graphics Ideas:

render fonts ourself
render font vertices directly
try font hinting

Implementation Ideas:

import a libc, like musl, so we can printf
that requires a preprocessor

struct Code_Node should use flags instead of bools

render_type should not use snprintf, we should prerender type str

Ideas:

we could let the user know at a glance when they use garbage memory
for that, we need to track set_memory and allocations and deallocations in a more detailed way

we could have comments show up when we press a button,
it might provide helpful information when debugging
what do we need to make this happen?

we could have the original whitespace show up in the code
it might increase comprehension
what do we need to make this happen?

what if we clone everything we run, instead of modifying stuff in place?

make a comma operator, see how parsing looks like

add page up and page down

pressing M makes the prev/next use/change check memory instead of ident
needs visual feedback

pressing Q will show the value of the ident under the inspection cursor or a repeated expression
useful for seeing where an ident or memory address or expression was used

pressing P will make the current dataflow hide points affect other dataflows

make an example that uses a lot of binary operations in a conditional

make a demo where we solve a nasty bug

we could contract nested if statements to reduce indentation, but declarations in them have to be transformed

pressing a button when the cursor is on an ident shows the value of that ident at that point in time
especially when it's the left hand side of an assign or opassign

we could set the execution to scroll automatically by some speed, and maybe bounce between flowpoints

we could find the bug, fix it live, recompile, and run directly from the buggy place to check if it was fixed