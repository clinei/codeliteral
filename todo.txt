Bugs:

jumping to a use makes it impossible to go left when it should be possible
going to right makes it possible again

reallocation of type_infos and code_node_array means we have to fix pointers in the tree
we have to calculate the diff of the last block and then add that to every pointer
or we can have node pointers relative to the base, that way we don't have to recalculate
but we have to convert from relative pointers to absolute every time we traverse the tree

we should use flags instead of bools

structs need alignment padding

else if can put a transformed block between an else if chain, not good visually

scrolling needs a separate layout pass

we call the left hand side "ident",
that is wrong, it's an lvalue
we should rename it

TYPE_INFO_TAG_IDENT should not exist or should be removed during infer
it makes it harder to do things later in the pipeline

unary minus and not operators not implemented

pressing V should only show parens when operator precedence changes

dynamic arrays as structs,
static arrays as pointers
array concatenation

casts
test ints

add asserts everywhere

Graphics Ideas:

backgrounds need a stack approach

render fonts ourself
render font vertices directly
try font hinting

Implementation Ideas:

import a libc, like musl, so we can printf
that requires a preprocessor

Ideas:

add a way to jump to the original code in the text editor, maybe as a toggle that makes the original code get selected when moving between nodes

side-by-side view of original and evaluated code, maybe this is useful?
have to deal with mismatching lines, though

we could let the user know at a glance when they use garbage memory
for that, we need to track set_memory and allocations and deallocations in a more detailed way

we could have comments show up when we press a button,
it might provide helpful information when debugging
what do we need to make this happen?

we could have the original whitespace show up in the code
it might increase comprehension
what do we need to make this happen?

what if we clone everything we run, instead of modifying stuff in place?

make a comma operator, see how parsing looks like

add page up and page down

pressing M makes the prev/next use/change check memory instead of ident
needs visual feedback

pressing Q will show the value of the ident under the inspection cursor or a repeated expression
useful for seeing where an ident or memory address or expression was used

pressing P will make the current dataflow hide points affect other dataflows

make an example that uses a lot of binary operations in a conditional

make a demo where we solve a nasty bug

we could contract nested if statements to reduce indentation, but declarations in them have to be transformed

pressing a button when the cursor is on an ident shows the value of that ident at that point in time
especially when it's the left hand side of an assign or opassign

we could set the execution to scroll automatically by some speed, and maybe bounce between flowpoints

we could find the bug, fix it live, recompile, and run directly from the buggy place to check if it was fixed